package com.dev.ops.device.registration.service.services;

import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Security;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.Enumeration;

import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.DEREncodable;
import org.bouncycastle.asn1.DERObjectIdentifier;
import org.bouncycastle.asn1.DERPrintableString;
import org.bouncycastle.asn1.cms.Attribute;
import org.bouncycastle.asn1.cms.AttributeTable;
import org.bouncycastle.asn1.pkcs.CertificationRequestInfo;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.ExtendedKeyUsage;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.bouncycastle.asn1.x509.KeyUsage;
import org.bouncycastle.asn1.x509.X509Extension;
import org.bouncycastle.asn1.x509.X509Extensions;
import org.bouncycastle.jce.PKCS10CertificationRequest;
import org.bouncycastle.util.encoders.Base64;
import org.bouncycastle.x509.X509V3CertificateGenerator;
import org.bouncycastle.x509.extension.AuthorityKeyIdentifierStructure;
import org.bouncycastle.x509.extension.SubjectKeyIdentifierStructure;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import sun.misc.BASE64Encoder;

import com.dev.ops.device.registration.service.constants.DeviceRegistrationConstants;
import com.dev.ops.logger.service.DiagnosticLogger;
import com.dev.ops.logger.service.LoggerFactory;

@SuppressWarnings({"deprecation"})
@Component
public class CertificateEnrollmentService {

	@Value("${device.registration.service.ca.certificate.file.path}")
	private String caCertificateFilePath;

	@Value("${device.registration.service.ca.certificate.password}")
	private String caCertificatePassword;

	@Value("${device.registration.service.ca.certificate.end.duration}")
	private String caCertificateEndDuration;

	private static final DiagnosticLogger DIAGNOSTIC_LOGGER = LoggerFactory.getDiagnosticLogger(CertificateEnrollmentService.class);

	public CertificateEnrollmentService() {
		Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
	}

	@SuppressWarnings({})
	public String getCertificate(final String encodedCSR) throws Exception {
		final PKCS10CertificationRequest certificateRequest = this.getPKCS10CertificationRequest(encodedCSR);

		//Generate PKCS12 keystore
		final KeyStore keyStrorePKCS12 = KeyStore.getInstance(DeviceRegistrationConstants.CertificateTypes.PKCS12);
		final X509Certificate rootCertificate = this.getCACertificate(keyStrorePKCS12);
		final PrivateKey privateKey = this.getPrivateKey(keyStrorePKCS12);

		final X509V3CertificateGenerator certificateGenerator = this.getCertificateGenerator(rootCertificate, certificateRequest);
		final X509Certificate issuedCertificate = certificateGenerator.generateX509Certificate(privateKey);
		final String encodedCertificate = new BASE64Encoder().encode(issuedCertificate.getEncoded());
		DIAGNOSTIC_LOGGER.debug("Certificate generated by CA: " + encodedCertificate);

		return encodedCertificate;
	}

	private X509Certificate getCACertificate(final KeyStore keyStrorePKCS12) throws Exception {
		final InputStream inStream = new FileInputStream(this.caCertificateFilePath);
		keyStrorePKCS12.load(inStream, this.caCertificatePassword.toCharArray());
		final String keyStoreAlias = keyStrorePKCS12.aliases().nextElement();
		final X509Certificate rootCACertificate = (X509Certificate) keyStrorePKCS12.getCertificate(keyStoreAlias);
		return rootCACertificate;
	}

	private PrivateKey getPrivateKey(final KeyStore keyStrorePKCS12) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {
		final String alias = keyStrorePKCS12.aliases().nextElement();
		final PrivateKey privateKey = (PrivateKey) keyStrorePKCS12.getKey(alias, this.caCertificatePassword.toCharArray());
		return privateKey;
	}

	private X509V3CertificateGenerator getCertificateGenerator(final X509Certificate rootCert, final PKCS10CertificationRequest request) throws Exception {

		final X509V3CertificateGenerator certificateGenerator = this.getDefaultCertificateGenerator(rootCert, request);
		final ASN1Set attributes = request.getCertificationRequestInfo().getAttributes();

		for(int attributeCounter = 0; attributeCounter != attributes.size(); attributeCounter++) {
			final Attribute attribute = Attribute.getInstance(attributes.getObjectAt(attributeCounter));

			if(attribute.getAttrType().equals(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest)) {
				final X509Extensions extensions = X509Extensions.getInstance(attribute.getAttrValues().getObjectAt(0));

				final Enumeration<?> objectIdentifiers = extensions.oids();
				while(objectIdentifiers.hasMoreElements()) {
					final DERObjectIdentifier objectIdentifier = (DERObjectIdentifier) objectIdentifiers.nextElement();
					final X509Extension extension = extensions.getExtension(objectIdentifier);
					certificateGenerator.addExtension(objectIdentifier, extension.isCritical(), extension.getValue().getOctets());
				}
			}
		}
		return certificateGenerator;
	}

	private X509V3CertificateGenerator getDefaultCertificateGenerator(final X509Certificate rootCert, final PKCS10CertificationRequest request) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, CertificateParsingException {
		final X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();
		certificateGenerator.setSerialNumber(BigInteger.valueOf(System.currentTimeMillis()));
		certificateGenerator.setIssuerDN(rootCert.getSubjectX500Principal());
		certificateGenerator.setNotBefore(new Date(System.currentTimeMillis()));
		certificateGenerator.setNotAfter(new Date(System.currentTimeMillis() + 31536000000L));
		certificateGenerator.setSubjectDN(request.getCertificationRequestInfo().getSubject());
		certificateGenerator.setPublicKey(request.getPublicKey());
		certificateGenerator.setSignatureAlgorithm(DeviceRegistrationConstants.RSAAlgorithms.SHA256_WITH_RSA_ENCRYPTION);
		certificateGenerator.addExtension(X509Extensions.AuthorityKeyIdentifier, false, new AuthorityKeyIdentifierStructure(rootCert));
		certificateGenerator.addExtension(X509Extensions.SubjectKeyIdentifier, false, new SubjectKeyIdentifierStructure(request.getPublicKey("BC")));
		certificateGenerator.addExtension(X509Extensions.BasicConstraints, true, new BasicConstraints(false));
		certificateGenerator.addExtension(X509Extensions.KeyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));
		certificateGenerator.addExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage(KeyPurposeId.id_kp_serverAuth));

		//X509v3CertificateBuilder certificateBuilder = new X509v3CertificateBuilder(rootCert.getSubjectX500Principal(), BigInteger.valueOf(System.currentTimeMillis()), new Date(System.currentTimeMillis()), new Date(System.currentTimeMillis()), request.getCertificationRequestInfo().getSubject(), request.getPublicKey());
		//X509v3CertificateBuilder certificateBuilder = new X509v3CertificateBuilder(rootCert.getSubjectX500Principal(), BigInteger.valueOf(System.currentTimeMillis()), new Date(System.currentTimeMillis()), new Date(System.currentTimeMillis() + new Long(caCertificateEndDuration)), null, null);
		return certificateGenerator;
	}

	public boolean validateCSR(final String encodedCSR, final String secreteChallenge) {
		boolean isValid = false;
		final PKCS10CertificationRequest certificateRequest = this.getPKCS10CertificationRequest(encodedCSR);

		final CertificationRequestInfo info = certificateRequest.getCertificationRequestInfo();
		final AttributeTable attributes = new AttributeTable(info.getAttributes());
		final Attribute challengeAttribute = attributes.get(PKCSObjectIdentifiers.pkcs_9_at_challengePassword);
		if(challengeAttribute != null) {
			// If it is a challengePassword directly, it's just to grab the value
			final ASN1Set values = challengeAttribute.getAttrValues();
			final DEREncodable derEncodable = values.getObjectAt(0);
			final String retrivedChallenge = DERPrintableString.getInstance(derEncodable).toString();

			if(retrivedChallenge.equals(secreteChallenge)) {
				isValid = true;
			}
		}
		return isValid;
	}

	private PKCS10CertificationRequest getPKCS10CertificationRequest(final String encodedCSR) {
		final String csr = this.getCSR(encodedCSR);
		DIAGNOSTIC_LOGGER.debug("CSR request received from device : " + csr);
		final byte[] base64DecodedCSR = Base64.decode(csr);
		return new PKCS10CertificationRequest(base64DecodedCSR);
	}

	private String getCSR(final String encodedCSR) {
		return encodedCSR.replaceAll("(?i)-----BEGIN CERTIFICATE REQUEST-----", "").replace("(?i)-----END CERTIFICATE REQUEST-----", "");
	}
}